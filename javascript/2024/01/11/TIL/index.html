<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/insidepixce-blog/assets/css/style.css">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>컴포넌트의 재사용성, 미들웨어, 리렌더링 | Insidepixce inworld</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="컴포넌트의 재사용성, 미들웨어, 리렌더링" />
<meta name="author" content="insidepixce" />
<meta property="og:locale" content="ko_KR" />
<meta name="description" content="독감은 독해서 독감이구나" />
<meta property="og:description" content="독감은 독해서 독감이구나" />
<meta property="og:site_name" content="Insidepixce inworld" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-01-11T18:00:00-09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="컴포넌트의 재사용성, 미들웨어, 리렌더링" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"insidepixce"},"dateModified":"2024-01-11T18:00:00-09:00","datePublished":"2024-01-11T18:00:00-09:00","description":"독감은 독해서 독감이구나","headline":"컴포넌트의 재사용성, 미들웨어, 리렌더링","mainEntityOfPage":{"@type":"WebPage","@id":"/insidepixce-blog/javascript/2024/01/11/TIL/"},"url":"/insidepixce-blog/javascript/2024/01/11/TIL/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>



    <div class="container">
        <!-- 사이드바 -->
        <aside class="sidebar">
            <div class="profile">
                <img src="/insidepixce-blog/logo.jpg" alt="Profile Picture" class="profile-picture">
                <a href="/insidepixce-blog/" style="text-decoration: none; color:#000000; font-size:20px;">Park gyodam</a>
                <p class="bio">방랑 개발자</p>
                <a href="https://www.instagram.com/outsidepixce/" target="_blank">Git</a>
                <a href="https://github.com/insidepixce" target="_blank">Instagram</a>
                <a href="mailto:insidepixce@gmail.com">이메일</a>
                
                <h3 style="color:black">Categories</h3>
                <ul class="category-list">
                    <p>전체 글 수 32 개</p>
                    
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/49challenge/index.html" class="category-title">49challenge (3)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/ect/index.html" class="category-title">ect (1)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/html-css/index.html" class="category-title">html-css (1)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/javascript/index.html" class="category-title">javascript (17)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/oz-coding/index.html" class="category-title">oz-coding (1)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/sec/index.html" class="category-title">sec (2)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/security/index.html" class="category-title">security (2)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/talk/index.html" class="category-title">talk (1)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                    <li>
                        <!-- 카테고리 링크를 category.html로 연결 -->
                        <a href="/insidepixce-blog/categories/test/index.html" class="category-title">test (1)</a>
                        <ul class="subcategory-list">
                            
                            
                            <li class="subcategory-title"></li>
                            
                        </ul>
                    </li>
                    
                </ul>
            </div>
        </aside>
        
        <!-- 메인 콘텐츠 -->
        <main class="content">
            <h1>컴포넌트의 재사용성, 미들웨어, 리렌더링</h1>
            <div class="page-content">
                    <article class="post">
    <header class="post-header">
        <p class="post-meta">
            2024년 01월 11일 | javascript
        </p>
    </header>
    


    <div class="post-content">
        <svg width="100%" height="5px">
            <line x1="0" y1="5" x2="5000" y2="5" stroke="#cccccc" stroke-width="6"/>
        </svg>
        <p>독감은 독해서 독감이구나</p>

<p>티아이엘.</p>
<h1 id="오늘의-피드백">오늘의 피드백</h1>

<h3 id="컴포넌트의-재사용성">컴포넌트의 재사용성</h3>

<p>컴포넌트의 재사용성 진짜 중요하다. 최적화와 너무 깊게 연관되어 있기 때문이다. 이번 프로젝트 진행 중 상품 목록 페이지를 개발하면서, 각 상품 카드를 표시하는 부분을 여러 곳에서 사용하여야 했다. 이러한 상황에서 재사용 가능한 컴포넌트를 어떻게 설계하고 최적화하는지에 대한 고민을 많이 하게 되었다.</p>

<p>재사용성을 높이기 위해 컴포넌트들을 작은 단위로 분류하고 props를 통해 데이터를 동적으로 전달하는 방식으로 개발했다. 또한, React.memo 나 PureComponent 와 같은 최적화 기술을 활용하여 불필요한 리렌더링을 방지하고 성능을 향상시키는 방법을 생각해봐야 할 것 같다</p>

<h3 id="상태-관리의-복잡성과-미들웨어">상태 관리의 복잡성과 미들웨어</h3>

<p>위에서 언급한 Redux를 사용하여 상태 관리를 하는데 복잡하더라. 특히 비동기 작업과 관련된 부분이 어려웠다. . Redux Thunk, Redux Saga, Redux Observable 등 미들웨어가 너무 많아서 어떤걸 선택해야 할지 혼란스러웠다. 비동기 작업을 효과적으로 처리하고 상태 관리의 복잡성을 줄이기 위해 Redux Thunk 를 활용하여 API 호출 및 데이터 처리를 구현해보았다. 고르기 진짜 힘들었따</p>

<h3 id="상태-최적화와-선택적-리렌더링">상태 최적화와 선택적 리렌더링</h3>

<p>→ 대규모 앱에서는 성능 최적화가 중요한 이슈이다. Reselect와 같은 라이브러리를 활용해보았지만 사실 나는 별다른걸 못 느꼈다.</p>

<h1 id="오늘의-이슈">오늘의 이슈</h1>

<ol>
  <li><strong>상품 목록을 불러오는 동안 네트워크 연결이 불안정한 상황에서 API 호출이 실패하는 문제가 발생했다.</strong></li>
</ol>

<p>→ Redux의 ‘fetchUser.rejected’ 케이스가 트리거되어 오류 메세지를 Redux 상태에 저장했다.’</p>

<p>앱이 서버로 api요청을 보내는 도중에 네트워크 연결이 불안정한 상황이 발생했다. API 호출이 실패하고 대신 오류 응답을 받게 되었다.</p>

<p>→ Redux의 ‘fetchUser.rejected’케이스 트리거: Redux를 사용하여 API 호출을 관리하고 있을 때, Redux Toolkit과 Redux Thunk 등을 활용하여 비동기 액션을 처리하는데, 호출이 실패하면 자동으로 ‘Rejected’케이스가 트리거된다. 이 경우, Redux에서 사용자가 정의한 ‘fetchUser’액션에 대한 ‘rejected’케이스가 실행된다</p>

<p>→’fetchUser.rejected’케이스에서는 API 호출 실패와 관련된 오류 메시지를 포함한 액션 객체가 생성된다. 이 오류 메시지는 Redux 상태에 저장되고, 일반적으로 Redux 상태에는 error 또는 errorMessage와 같은 필드가 있어 오류 메시지를 저장할 수 있다</p>

<p>👰🏻 사실 불안정한 네트워크 연결에 대한 해결책은 아니다. 길이 없는데 어떻게 가겠는가. 그냥, 오류 메시지를 어떻게 담을 것인지 확인했다.</p>

<ol>
  <li><strong>사용자 인증 토큰이 만료되어 API 요청이 실패했다</strong></li>
</ol>

<p>→ 토큰 만료를 감지하고 리프레시 토큰을 사용하여 새로운 액세스 토큰을 얻어 API 요청을 재시도한다</p>

<p>→ 인증 토큰 만료에 대한 오류 핸들링을 통해 사용자에게 다시 로그인을 유도한다</p>

<p>이것도 Redux의 도움을 얻어보았다. fetchUser액션에서 토큰 만료 오류가 발생했을 때 리프레시 토큰을 사용하여 새로운 액세스 토큰을 얻는 과정이다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const fetchUser = createAsyncThunk('user/fetchUser', async (_, { dispatch, rejectWithValue }) =&gt; {
  try {
    const response = await fetch('/api/user', {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
    const data = await response.json();
    return data;
  } catch (error) {
    // 토큰 만료 오류인 경우 리프레시 토큰을 사용하여 재인증 시도
    if (error.message === 'TokenExpiredError') {
      try {
        const newAccessToken = await dispatch(refreshToken());
        // 새로 받은 액세스 토큰을 사용하여 다시 API 요청을 시도
        const response = await fetch('/api/user', {
          headers: {
            Authorization: `Bearer ${newAccessToken}`,
          },
        });
        const data = await response.json();
        return data;
      } catch (refreshError) {
        // 리프레시 토큰으로도 재인증에 실패한 경우
        return rejectWithValue('로그인이 필요합니다.'); // 오류 메시지 반환
      }
    }
    return rejectWithValue(error.message);
  }
});
</code></pre></div></div>

<ol>
  <li>서<strong>버에서 받은 데이터의 유효성을 검사하는 과정에서 실패했다</strong></li>
</ol>

<p>외부 데이터 소스에서 데이터를 가져와서 사용하는 중이였는데, 데이터 형식이 일치하지 않아 오류가 발생했다.</p>

<p>데이터 유효성 검사 오류 = 애플리케이션 서버로부터 받은 데이터가 예상과 다른 형식이거나 유효하지 않을 때 발생할 수 있는 어려움이다. → 데이터 형식 명확히 정의하기 : 서버와 클라이언트간에 통신할때 데이터의 형식을 명확히 정의해야 한다.</p>

<p>→ Joi /Yup 과 같은 유효성 검사 라이브러리를 사용한다 : 클라이언트 측에서는 Joi 나 Yup 같은 유효성 검사 라이브러리를 사용하여 데이터의 유효성을 간편하게 검사할 수 있다. 이러한 라이브러리를 활용하면 데이터 스키마를 정의하고 데이터를 검증하는 과정을 간소화할 수 있다</p>

<h1 id="화면-전환시에-화면전환-애니를-사용자-정의하고-싶다면">화면 전환시에 화면전환 애니를 사용자 정의하고 싶다면?</h1>

<p>작업 중에 조금 밋밋했던 부분이 있었다. 리엑트 네이티브에서 화면 전환 애니메이션을 사용자 정의하는 것이 가능하고, ‘react-navigation’이라는 라이브러리를 활용하여 구현할 수 있다’</p>

<p>화면 전환 애니메이션을 구현하려면 ‘createStackNavigator’함수를 사용하여 네비게이션 스택을 만들고, screenOptions 속성을 활용하여 사용자 정의 애니메이션을 설정해줄 수 있다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">NavigationContainer</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@react-navigation/native</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">createStackNavigator</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@react-navigation/stack</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">Stack</span> <span class="o">=</span> <span class="nf">createStackNavigator</span><span class="p">();</span>

<span class="kd">function</span> <span class="nf">App</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">NavigationContainer</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Navigator</span>
        <span class="na">initialRouteName</span><span class="p">=</span><span class="s">"Home"</span>
        <span class="na">screenOptions</span><span class="p">=</span><span class="si">{</span><span class="p">{</span>
          <span class="na">cardStyleInterpolator</span><span class="p">:</span> <span class="p">({</span> <span class="nx">current</span><span class="p">,</span> <span class="nx">layouts</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span>
              <span class="na">cardStyle</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">transform</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="na">translateX</span><span class="p">:</span> <span class="nx">current</span><span class="p">.</span><span class="nx">progress</span><span class="p">.</span><span class="nf">interpolate</span><span class="p">({</span>
                      <span class="na">inputRange</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="na">outputRange</span><span class="p">:</span> <span class="p">[</span><span class="nx">layouts</span><span class="p">.</span><span class="nx">screen</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="p">}),</span>
                  <span class="p">},</span>
                <span class="p">],</span>
              <span class="p">},</span>
            <span class="p">};</span>
          <span class="p">},</span>
        <span class="p">}</span><span class="si">}</span>
      <span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Screen</span> <span class="na">name</span><span class="p">=</span><span class="s">"Home"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">HomeScreen</span><span class="si">}</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Screen</span> <span class="na">name</span><span class="p">=</span><span class="s">"Details"</span> <span class="na">component</span><span class="p">=</span><span class="si">{</span><span class="nx">DetailsScreen</span><span class="si">}</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">Stack</span><span class="p">.</span><span class="nc">Navigator</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">NavigationContainer</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>
<p>화면 전환 시 애니메이션이 오른쪽으로 슬라이드되는 효과를 정의해보았다. ‘cardStyleInterpolator’ 함수 내에서 애니메이션을 정의했다. ‘inputRange’와 ‘outputrange’를 조절하여 다양한 애니메이션 효과를 적용했다</p>

<p>저건 연습 코드였고, 실제 프로젝트에서는 좀 더 복잡한 애니메이션을 구현해줬는데, react-navigation 라이브러리의 다양한 옵션들을 정리해보려 한다.</p>

<h3 id="내가-주로-쓸-것-같은-옵션들-모음-react-navigation-">내가 주로 쓸 것 같은 옵션들 모음 (react-navigation )</h3>

<ul>
  <li><strong>createStackNavigator - ‘screenOptions’</strong></li>
</ul>

<p>스택 네비게이터를 생성할 때 화면 전환에 관련된 옵션 설정가능</p>

<p>‘cardStyleInterpolator : 화면 전환 애니메이션을 사용자 정의할 수 있게 하는 함수를 지정한다. 화면 슬라이드. 페이드, 회전 등 다양한 애니메이션 효과 정의 가능! !</p>

<p>‘headerStyle’: 화면 헤더의 스타일을 설정한다. 배경색, 그림자, 높이 등을 조절할 수 있다</p>

<p>‘headerTintColor’: 헤더 아이콘 및 텍스트의 샞상을 설정한다</p>

<p>‘headerTitleStyle” : 헤더 제목의 스타일 설정</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‘createBottomTabNavigator’ 및 ‘createMaterialBottomTabNavigator’**
</code></pre></div></div>
<p>탭 네비게이터 생성 시 다양한 옵션을 사용하여 탭의 모양과 동작을 조절할 수 있다. 예를 들어 , ‘ tabBarIcon’을 사용하여 각 탭에 아이콘을 지정하거나, ‘tabBarOptions’를 사용하여 탭바의 스타일을 설정할 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-   **‘createDrawerNavigator’:**
</code></pre></div></div>
<p>드로어 네비게이터를 생성할 때 ‘drawerContent’나 ‘drawerStyle’등을 사용하여 드로어의 내용과 스타일을 조절할 수 있다</p>

<h1 id="데이터베이스-충돌">데이터베이스 충돌</h1>

<p>데이터베이스에 사용자 정보를 저장했다. 근데, 동시에 두 사용자가 동일한 사용자 정보를 수정하려고 시도하면 어떻게 될까 궁금해서 해봤다.</p>

<ul>
  <li>사용자 A는 웹 앱에서 자신의 사용자 정보를 수정하려고 한다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const updateUserA = async () =&gt; {
	const user = await getUserFromDB(1);\\
	user.age = 31;
	await updateUserInDB(user);
};
</code></pre></div></div>

<ul>
  <li>동일한 시간에 사용자 B도 자신의 정보를 수정하려고 한다</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const updateUserB = async () =&gt; {
	const user = await getUIserFromDB(1);
	user.age = 32;
	await updateUserInDB(user);
</code></pre></div></div>

<p>→ 충돌 발생</p>

<ul>
  <li>사용자 a와 사용자 b는 동시에 데이터베이스에서 동일한 사용자 정보를 가져와 수정하고 저장하려고 한다. 데이터베이스에는 사용자 a와 b가 동시에 업데이트를 시도하므로 충돌이 발생한다</li>
  <li>충돌이 발생한 후 , 데이터베이스에서 최정적으로 저장된 사용자 정보를 마지막으로 업데이트해서 반영한다</li>
</ul>

<h2 id="충돌이-해결되는-과정">충돌이 해결되는 과정</h2>

<ol>
  <li>데이터베이스 업데이트</li>
</ol>

<ul>
  <li>사용자 A와 사용자 B가 동시에 데이터베이스의 사용자 정보를 가져오고 수정합니다.</li>
  <li>각각의 업데이트는 데이터베이스 트랜젝션 내에서 처리된다</li>
</ul>

<ol>
  <li>데이터베이스 충돌 감지</li>
</ol>

<ul>
  <li>데이터베이스는 사용자 A와 사용자 B의 업데이트가 동시에 실행되어 충돌이 발생했음을 감지한다</li>
</ul>

<ol>
  <li>충돌 해결</li>
</ol>

<ul>
  <li>충돌 해결에는 두가지 방법이 있다.
    <ul>
      <li>비관적 잠금 (Pessimistic Locking) : 사용자 A가 데이터를 가져올 때 데이터베이스에서 해당 데이터를 잠그고, 사용자 B는 데이터를 가져오는 동안 기다려야 한다. 이후 사용자 A와 B중 먼저 업데이트를 시도한 사용자의 변경 내용이 반영된다</li>
      <li>낙관적 잠금(Optimistic Locking) : 사용자 A와 B가 데이터를 가져온 후 업데이트를 시도한다. 데이터베이스에서는 A와 B애가 가져온 데이터의 버전을 비교한다. 만약 버전이 동일하다면 업데이트를 허용하고 , 버전이 다르다면 충돌이 감지되었다고 알린다. 이후 A와 B에게 충돌을 해결하라고 선택권을 주거나, 나중에 다시 시도하도록 유도한다</li>
    </ul>
  </li>
</ul>

<ol>
  <li>최종 업데이트</li>
</ol>

<ul>
  <li>충돌이 해결되고 데이터베이스에서 사용자 A와 B의 업데이트를 모두 반영한 후 , 최종 사용자 정보가 데이터베이스에 저장된다</li>
  <li>이때, 마지막으로 업데이트한 사용자의 변경 내용이 반영되므로, 최종 나이가 32인 경우에는 사용자 B의 업데이트가 마지막으로 반영된 경우이다.</li>
</ul>

<ol>
  <li>응답 및 결과</li>
</ol>

<ul>
  <li>데이터베이스가 최종 업데이트를 수행한 후 , 사용자 A와 B에게 각각의 요청에 대한 응답을 반환합니다</li>
  <li>응답은 수정 후의 최종 결과를 나타내며, 데이터베이스에서 저장된 최신 상태를 반영한다</li>
</ul>

<p>이렇게 충돌이 발생하고 해결되면 최종적으로 데이터베이스에 반영된 결과를 사용자 A와 B에게 반환하여 제공된다. 충돌이 발생할 경우 충돌 해결 전까지 어느 한 사용자의 업데이트가 최종 반영되지 않은 것이다</p>

<h2 id="오늘-하루-리뷰">오늘 하루 리뷰 </h2>

<p>오늘 몸이 너무 안따라준다. 헤롱헤롱한다. 너무 아프다. 진짜 두통이 너무 심하다. 글자를 읽을 때마다 울렁거린다. 약간 속도 메스껍고 토할 것 같다. 잠이 너무 온다. 죽을 것 같다 진짜. 속도 안좋다. 잠도 많이 온다. 어제부터 죽을 것 같아서 몬스터 흰색 캔을 2개를 땄다. 어쩌겠니… 돈벌어야 하는데…</p>

<p>몸이 너무 아프다. 잠이 너무 많아진다. 이러다가 진짜 죽는건 아닐지 하고 아픈데 열은 또 안 난다. 춥고 덥다. 근데 또 갑자기 미친듯이 먹고싶을때가 있다. 또 밥먹기 싫을때는 미친듯이 먹기 싫다.</p>

<p>이게 무슨 일이람… 내과 가서 물어봐야 하나,,,</p>

<p>글자 보면 울렁거려서 못참겠다니깐.</p>

<p>그래도 해야지 어떡해…그래도 해야지 어떡해.</p>

<p>독감이 괜히 독감이 아닌가봐…독해서 독감이야</p>

    </div>

    <footer class="post-footer">
        
            <p>태그: javascript</p>
        

        
            <h3>댓글</h3>
            <!-- 댓글 시스템 통합 (예: Disqus) -->
        
    </footer>

  
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = '/javascript/2024/01/11/TIL/';
      this.page.identifier = '/javascript/2024/01/11/TIL/';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://mylog-3.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>


    <nav class="post-navigation">
        <p></p>
        <p> 다음 게시물: <a href="/javascript/2024/01/11/itsone/">암호화 키 오류</a> </p>
    </nav>
</article>

            </div>
        </main>
    </div>

    <footer class="site-footer">
                             <p>                       </p>&copy; 2024 Insidepixce inworld - All rights reserved. 디자인은 너무 어려워 
    </footer>
</body>
</html>
